# rabuf Library Requirements

## 1. Core Functionality

*   **Buffered File I/O:** The library must provide a buffered file reader/writer (`RaBuf`) that wraps a standard `File` object to optimize random access file operations.
*   **Chunk-Based I/O:** All file reading and writing operations should be performed in fixed-size chunks to minimize the number of system I/O calls.
*   **Random Access:** The `RaBuf` must support seeking to arbitrary positions within the file for both reading and writing, similar to `std::io::Seek`.

## 2. Performance Optimizations

*   **Caching:** The library must cache recently accessed file chunks in memory to accelerate subsequent reads and writes to the same file regions.
*   **Configurable Caching:**
    *   The number of chunks to cache (`max_num_chunks`) must be configurable.
    *   The size of each chunk (`chunk_size`) must be configurable and a power of two.
*   **Cache Eviction Strategy:** When the cache is full, the library must employ a Least Frequently Used (LFU) or a similar eviction strategy to remove less-used chunks.
*   **Fast Small I/O:** The library must provide optimized methods for reading and writing small, fixed-size data types (e.g., `u8`, `u16`, `u32`, `u64`) to and from the buffer.

## 3. API and Trait Implementations

*   **Standard Traits:** The `RaBuf` struct must implement the following standard Rust traits:
    *   `std::io::Read`
    *   `std::io::Write`
    *   `std::io::Seek`
    *   `Drop` (to ensure buffers are flushed on scope exit)
*   **Custom Traits:** The library must define and implement the following custom traits for enhanced functionality:
    *   `FileSetLen`: To truncate or extend the underlying file.
    *   `FileSync`: To synchronize the file's in-memory state with the disk.
    *   `SmallRead`: For optimized reading of small data types.
    *   `SmallWrite`: For optimized writing of small data types.
*   **`MaybeSlice`:** The library must provide a `MaybeSlice` enum that can represent either a slice of the in-memory buffer (`&[u8]`) or an owned buffer (`Vec<u8]`), allowing for efficient data access without unnecessary copying.

## 4. Optional Features (via Cargo features)

The library should provide the following optional features, configurable via Cargo:

*   `buf_auto_buf_size`: Automatically adjust the buffer size based on the file size.
*   `buf_hash_turbo`: Use a faster hash map implementation for chunk lookups.
*   `buf_myhash`: Use a custom hasher for the hash map.
*   `buf_lru`: Use a Least Recently Used (LRU) cache eviction strategy.
*   `buf_stats`: Collect and expose statistics about buffer usage.
*   `buf_print_hits`: Print cache hit/miss statistics to stderr.
*   `buf_debug`: Enable debug assertions and other debugging aids.
*   `buf_overf_rem`: Control the behavior when the buffer overflows.

## 5. Error Handling

*   All I/O operations must return `std::io::Result` to properly propagate errors.

## 6. Examples and Documentation

*   The library must provide clear and comprehensive documentation with examples demonstrating its usage.
*   The examples should cover common use cases, such as:
    *   Writing to a file, seeking, and then reading back the data.
    *   Writing to a file, closing it, and then re-opening it for reading.

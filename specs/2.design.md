# rabuf Design Document

## 1. Introduction

This document outlines the design of the `rabuf` library, a Rust library for buffered random access file I/O. The design is based on the acceptance criteria outlined in `specs/1.acceptance-criteria.md` and the existing source code in the `src` directory.

## 2. System Architecture

The `rabuf` library is designed as a wrapper around a `std::fs::File` object, providing a buffered interface for reading and writing data. The core of the library is the `RaBuf<T>` struct, which manages a collection of in-memory chunks of the file's data.

### 2.1. Components

*   **`RaBuf<T: Seek + Read + Write>`:** The main struct that provides the buffered file I/O functionality. It holds the underlying file handle, the chunk cache, and the current file position.
*   **`Chunk`:** A struct representing a single chunk of the file's data. It contains the chunk's data as a `Vec<u8>`, its offset within the file, a dirty flag to indicate if it needs to be written to disk, and a usage counter for the cache eviction policy.
*   **`OffsetIndex`:** A helper struct that maps file offsets to chunk indices in the `chunks` vector. This is implemented as either a `Vec<(u64, usize)>` or a `HashMap<u64, usize>` depending on the `buf_hash_turbo` feature flag.
*   **`MaybeSlice<'a>`:** An enum that represents either a slice of a chunk's data (`&'a [u8]`) or an owned buffer (`Vec<u8>`). This allows for efficient reading of data without unnecessary copying.

### 2.2. Data Flow

When a read or write operation is requested, the `RaBuf` struct first determines which chunk the data belongs to. If the chunk is already in the cache, the operation is performed directly on the in-memory data. If the chunk is not in the cache, it is read from the file into a new `Chunk` object and added to the cache. If the cache is full, the least frequently used chunk is evicted to make room for the new chunk.

## 3. Detailed Design

### 3.1. `RaBuf<T>` Struct

The `RaBuf<T>` struct will have the following fields:

*   `name: String`: A name for the buffer, used for debugging purposes.
*   `max_num_chunks: usize`: The maximum number of chunks to keep in the cache.
*   `chunk_size: usize`: The size of each chunk in bytes.
*   `chunk_mask: u64`: A bitmask used to calculate the offset of a chunk.
*   `chunks: Vec<Chunk>`: The in-memory cache of file chunks.
*   `map: OffsetIndex`: The mapping from file offsets to chunk indices.
*   `file: T`: The underlying file handle.
*   `pos: u64`: The current position in the file.
*   `end: u64`: The total size of the file.
*   `fetch_cache: Option<(u64, usize)>`: A cache for the last fetched chunk to speed up sequential access.

### 3.2. `Chunk` Struct

The `Chunk` struct will have the following fields:

*   `data: Vec<u8>`: The chunk's data.
*   `offset: u64`: The offset of the chunk within the file.
*   `dirty: bool`: A flag indicating whether the chunk has been modified and needs to be written to the file.
*   `uses: u32`: A counter for the number of times the chunk has been accessed, used for the LFU cache eviction policy.

### 3.3. Trait Implementations

The `RaBuf<T>` struct will implement the following traits:

*   `Read`: For reading data from the file.
*   `Write`: For writing data to the file.
*   `Seek`: For changing the current position in the file.
*   `Drop`: To flush any dirty chunks to the file when the `RaBuf` instance goes out of scope.
*   `FileSetLen`: For truncating or extending the file.
*   `FileSync`: For synchronizing the file with the disk.
*   `SmallRead`: For optimized reading of small data types.
*   `SmallWrite`: For optimized writing of small data types.

## 4. Optional Features

The library will support the following optional features, controlled by Cargo feature flags:

*   `buf_auto_buf_size`: Automatically adjust the buffer size based on the file size.
*   `buf_hash_turbo`: Use a `HashMap` for the `OffsetIndex` for faster chunk lookups.
*   `buf_myhash`: Use a custom hasher for the `HashMap`.
*   `buf_lru`: Use a Least Recently Used (LRU) cache eviction strategy.
*   `buf_stats`: Collect and expose statistics about buffer usage.
*   `buf_print_hits`: Print cache hit/miss statistics to stderr.
*   `buf_debug`: Enable debug assertions and other debugging aids.
*   `buf_overf_rem`: Control the behavior when the buffer overflows.
